"""
Pre-computed Detection Support Module

This module provides functionality to load and use pre-computed detections
from JSON files generated by the pre-rendering script.

Usage:
    from video_track_precomputed import load_precomputed_detections, get_detection_for_frame

    # Load detections once
    detections_map = load_precomputed_detections("path/to/video.detections.json")

    # Get detections for specific frame
    frame_detections = get_detection_for_frame(detections_map, frame_number)
"""

import json
from pathlib import Path
from typing import Dict, List, Any, Optional
from loguru import logger


def load_precomputed_detections(json_path: str) -> Optional[Dict[int, List[Any]]]:
    """
    Load pre-computed detections from JSON file.

    Args:
        json_path: Path to detections JSON file (*.detections.json)

    Returns:
        Dictionary mapping frame_number -> list of detections
        Returns None if file not found or loading fails
    """
    try:
        path = Path(json_path)
        if not path.exists():
            logger.warning(f"Pre-computed detections file not found: {json_path}")
            return None

        logger.info(f"Loading pre-computed detections from: {json_path}")

        with open(path, 'r') as f:
            metadata = json.load(f)

        # Build frame_number -> detections mapping
        detections_map = {}
        frames_data = metadata.get('frames', [])

        for frame_data in frames_data:
            frame_num = frame_data['frame_number']
            detections = frame_data['detections']
            detections_map[frame_num] = detections

        total_frames = len(detections_map)
        total_detections = sum(len(dets) for dets in detections_map.values())

        logger.info(
            f"✓ Loaded {total_detections} detections across {total_frames} frames"
        )

        return detections_map

    except Exception as e:
        logger.error(f"Failed to load pre-computed detections: {e}")
        return None


def get_detection_for_frame(
    detections_map: Dict[int, List[Any]],
    frame_number: int
) -> List[Any]:
    """
    Get detections for a specific frame.

    Args:
        detections_map: Dictionary from load_precomputed_detections()
        frame_number: Frame index to get detections for

    Returns:
        List of detection dictionaries for this frame (empty list if no detections)
    """
    if detections_map is None:
        return []

    # Handle looping videos: use modulo for frame lookup
    total_frames = max(detections_map.keys()) + 1 if detections_map else 1
    lookup_frame = frame_number % total_frames

    return detections_map.get(lookup_frame, [])


def find_detection_json_for_rtsp(rtsp_url: str, camera_id: str) -> Optional[str]:
    """
    Auto-detect the pre-computed detections JSON file for an RTSP stream.

    This function attempts to find the corresponding .detections.json file
    for a camera by looking in the rendered videos directory.

    Args:
        rtsp_url: RTSP stream URL (e.g., "rtsp://localhost:8554/camera1")
        camera_id: Camera identifier (e.g., "camera1")

    Returns:
        Path to detections JSON file if found, None otherwise
    """
    # Map camera IDs to expected rendered video names
    camera_video_mapping = {
        'camera1': 'people-detection-rendered',
        'camera2': 'car-detection-rendered',
        'camera3': 'person-bicycle-car-detection-rendered',
    }

    video_name = camera_video_mapping.get(camera_id)
    if not video_name:
        return None

    # Build path to detections JSON
    # Assumes structure: shared/cameras/rendered/{name}.detections.json
    project_root = Path(__file__).parent.parent.parent.parent
    detections_path = (
        project_root / "shared" / "cameras" / "rendered" /
        f"{video_name}.detections.json"
    )

    if detections_path.exists():
        logger.info(f"✓ Found pre-computed detections for {camera_id}")
        return str(detections_path)

    logger.debug(f"No pre-computed detections found for {camera_id} at {detections_path}")
    return None
