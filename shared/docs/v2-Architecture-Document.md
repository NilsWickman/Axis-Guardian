# Software Architecture Document  
**Project:** Site-level Video Surveillance System  
**Version:** v2 — September 21, 2025  
**Company:** Company 2  

---

## 1. Introduction  

### 1.1 Purpose  
This system provides site-level security surveillance with situational awareness. It helps customers monitor and protect entire facilities, reduce false alarms, and deter intruders effectively through loudspeakers.  

### 1.2 Scope  
- Multi-camera metadata aggregation  
- Geospatial alarm zones (site-level, not per camera)  
- Real-time anomaly detection and alarms  
- Map-based visualization (zones, heatmaps, intruder tracking)  
- Loudspeaker deterrence actions  
- Video verification on demand  

### 1.3 Definitions  
- **Site Map**: 2D-render of the monitored facility  
- **Zone**: User-defined area on the site map  
- **Alarm**: Triggered event when an intruder enters a restricted zone  
- **Intruder**: Unauthorized person in restricted zone  
- **Operator**: System user monitoring alerts and incidents  
- **Heatmap**: Visualization of movement density across site  
- **Incident**: Traceable security event generated by alarm acknowledgement  

### 1.4 Audience  
- **Development team**: Blueprint for implementation & integration  
- **Product managers**: Align requirements with technical feasibility  
- **Customer IT/security staff**: Deployment, integration, compliance, reliability  

---

# 2. System Overview

The application is designed using a layered architecture to support scalable, modular, and maintainable site-level surveillance. Each layer has distinct responsibilities.

---

## 2.1 Device Layer

### 2.1.1 Purpose
- Integrate physical devices  
- Provide raw RTSP video and device-native (unified but not normalized) metadata to the collector  
  - (Device Layer only forwards raw or semi-structured metadata; schema normalization is handled in the Collection Layer.)  
- Perform RTSP → WebRTC transcoding at the edge for low-latency browser playback  
- Health-check devices (status of the device needs to be constantly monitored to ensure that the camera/speaker is available online)

---

### 2.1.2 Components
- **Axis Device Service (Python)**  
  - Interacts with the device using the Axis SDK or VAPIX API protocol  
  - Maintains RTSP connections, subscribes to camera metadata, and controls loudspeakers  

- **Device Manager (Edge)**  
  - Tracks device registry, device heartbeat, last-seen, firmware/version, network metrics  

- **Edge Health Agent**  
  - Periodic checks (ping, RTSP connect test, metadata freshness)  

- **WebRTC Gateway (Edge, e.g. Janus/mediasoup/GStreamer)**  
  - Consumes RTSP streams from cameras  
  - Transcodes or repackages RTSP into WebRTC (VP8/H.264 + Opus)  
  - Provides media relay only  
  - Signaling (SDP/ICE exchange, JWT authentication) is handled exclusively by the Service Layer  

---

### 2.1.3 Interfaces & Protocols
- **RTSP**  
  - Used to stream raw video from Axis cameras to the edge node  
  - Consumed locally for snapshot extraction and metadata alignment  
  - Not forwarded directly to the browser  
  - Connections maintained by device control logic and monitored for stability  

- **WebRTC (media)**  
  - Output from WebRTC Gateway → delivered to browser clients  
  - Signaling (SDP/ICE exchange, authentication) is not handled at the Edge; provided by the Service Layer  

- **Metadata Push (HTTP/JSON)**  
  - Device Layer pushes raw or semi-structured device-native metadata (camera-specific fields, timestamps, event details) to the Collector  
  - Collector normalizes into canonical schema  
  - Each payload includes device ID, timestamp, and event details  
  - Collector exposes `/metadata` endpoint to receive updates  

- **Speaker Control (Axis VAPIX API over HTTP)**  
  - Loudspeaker commands (play audio, stop playback, test tone) sent via HTTP requests to Axis VAPIX API  
  - Edge node exposes `/control` endpoint to receive control instructions from central system  
  - Relays commands to appropriate speaker device based on proximity logic  

---

### 2.1.4 Data Model (example device registration JSON)

```json
{
  "device_id": "cam-001",
  "type": "camera",
  "model": "Axis-AXIS-123",
  "ip": "10.0.0.12",
  "position": {"x": 42.3, "y": 10.2},
  "heading": 175.0,
  "capabilities": ["rtsp", "metadata", "snapshot"]
}
```

---

### 2.1.5 Implementation Notes

#### Edge Deployment
- Device control logic (Axis API client) deployed on shared edge nodes close to physical devices  
- Reduces latency and bandwidth usage  
- Each node runs lightweight Python service (Flask), containerized via Docker  
- Configured with device IPs and credentials  
- Maintains RTSP connections, retrieves metadata, controls loudspeakers via Axis VAPIX API  
- Exposes HTTP endpoints for snapshot retrieval, metadata forwarding, and speaker control  

#### Snapshot Caching
- Each edge node caches latest valid video frame from each camera as lightweight JPEG  
- Refreshed every 1–2 seconds using OpenCV  
- Timestamp ensures freshness  
- Cached frame accessible via HTTP endpoint (e.g., `/snapshot?device_id=cam-001`) for alarm verification when live video unavailable  

#### WebRTC Gateway
- Runs as sidecar service (e.g., Janus/mediasoup)  
- Handles multiple concurrent camera streams  
- Optimized for low-latency delivery (<1s)  

---

### 2.1.6 Failure Modes & Mitigation

- **RTSP disconnects**  
  - System monitors RTSP connectivity per device  
  - Reconnect using exponential backoff (2s, 4s, 8s...)  
  - If failed attempts exceed threshold (e.g., 5), device marked as *degraded* and flagged for operator attention  

- **Device unreachable**  
  - Periodic health checks (ping, RTSP connect test) by Edge Health Agent  
  - If unreachable, status escalated to Device Manager  
  - Registry updated and operator notified via UI  

- **Missing metadata**  
  - If camera fails to provide metadata for defined duration (e.g., 5s), system switches to visual-only detection mode at Analytics Layer  
  - Ensures continued intruder detection using image-based analysis  

- **WebRTC Gateway failure**  
  - Fallback to snapshot evidence  
  - Operator notified: *“live video unavailable”*  
  - Automatic restart of gateway container  

## 2.2 Collection Layer

### 2.2.1 Purpose
- Ingest raw/semi-structured metadata from Device Layer and normalize it into the canonical detection schema.  
- Forward standardized detections to the Analytics Layer reliably and at scale.  
- Persist snapshot references for evidence.  

> Note: Device health is already managed and surfaced by the Device Layer; no additional forwarding is required here.

---

### 2.2.2 Components

- **Collector Worker (Edge / Cloud)**  
  - Receives metadata events from Device Layer (`/metadata` HTTP POST).  
  - Normalizes device-native metadata into the canonical detection schema.  
  - Attaches ingestion metadata (e.g., `ingest_time`, `source_device`, `sequence_id`).  

- **Message Broker**  
  - MQTT for low-latency pub/sub.  
  - Kafka for higher-throughput and replay.  
  - Topics: `detections.normalized` (canonical events).  

- **Snapshot Service**  
  - Requests cached frames from Device Layer (`/snapshot?device_id=...`).  
  - Stores frames in S3/MinIO with signed references.  
  - Attaches `frame_ref` to detection events for evidence.  

---

### 2.2.3 Interfaces & Protocols

- **Metadata Ingestion**  
  - **Input:** HTTP POST from Device Layer → `/metadata` (raw/semi-structured).  
  - **Output:** Collector normalizes into canonical schema and publishes to `detections.normalized`.  

- **Snapshot Retrieval**  
  - **Input:** HTTP GET → Device Layer `/snapshot`.  
  - **Output:** Store to S3/MinIO, return signed URL.  

---

### 2.2.4 Canonical Detection Schema (example)

```json
{
  "detection_id": "uuid-123",
  "device_id": "cam-001",
  "timestamp": "2025-09-17T22:12:31Z",
  "object": {
    "type": "person",
    "confidence": 0.92,
    "bbox": {"x": 0.12, "y": 0.23, "w": 0.10, "h": 0.40}
  },
  "geo": {"lat": 59.3293, "lon": 18.0686, "x": 42.3, "y": 10.2},
  "frame_ref": "s3://snapshots/site1/uuid-123.jpg",
  "sequence_id": 4567,
  "ingest_time": "2025-09-17T22:12:32Z"
}
```

### 2.2.5 Implementation Notes
- Validate schema at ingestion; reject malformed messages and log metrics.  
- Use JSON initially.  
- Ensure idempotency with `detection_id` and `sequence_id`.  
- Snapshots stored in S3/MinIO with lifecycle policies (e.g., auto-expire after N days).  

---

### 2.2.6 Failure Modes & Mitigation
- **Broker backlog** → Apply back-pressure, degrade sampling rate.  
- **Snapshot retrieval fail** → Continue analytics with metadata only, mark evidence as missing.  
- **Malformed metadata** → Reject and log, do not propagate downstream.  

---

### Design Rationale
Although Device Layer and Collection Layer are described separately for clarity of responsibilities, the initial implementation may combine them into a single service for simplicity.  

However, the logical boundary remains:  
- **Device Layer** = device integration and raw data forwarding  
- **Collection Layer** = schema normalization and reliable ingestion  

---

## 2.3 Analytics Layer

### 2.3.1 Purpose
- Consume normalized detections from Collection Layer.  
- Enrich with tracking and geo-mapping.  
- Apply rule-based evaluation.  
- Generate alarms.  
- Record movement traces (track points) for heatmap visualization.  
- Aggregation and API queries are handled in the Service Layer.  

---

### 2.3.2 Submodules
- **Tracker**  
  - Assigns `track_id` to objects.  
  - Performs per-camera tracking (DeepSORT / ByteTrack).  
  - Cross-camera reconciliation uses geo-proximity and timing (basic spatio-temporal stitching).  

- **Geo-Mapper**  
  - Projects box center into site coordinates using calibration data from Device Layer.  

- **Rule Engine**  
  - Evaluates zone/line/schedule rules from Config Service.  

- **False-Alarm Filter**  
  - Applies persistence, trajectory plausibility, and size/speed heuristics.  

- **Alarm Builder**  
  - Uses `frame_ref` from Collection Layer.  
  - Selects best camera, creates alarm event, writes to Alarm Service.  

- **Heatmap Aggregator**  
  - Persists all object trajectories (`track_id`, `timestamp`, `x`, `y`, `zone_id`) into the spatio-temporal database (PostgreSQL + PostGIS).  
  - Does not perform aggregation.  
  - Aggregation and visualization queries are provided by the Heatmap Service in the Service Layer.  

---

### 2.3.3 Algorithms & Implementation

**Tracking**  
- Per-camera: DeepSORT / ByteTrack for ID continuity.  
- Cross-camera: simple reconciliation by geo-proximity + temporal overlap.  
- (Optional extension: use appearance embeddings for improved identity matching.)  

**Geo-projection**  
- Each camera is registered with a calibration matrix (homography).  
- Detections projected into the site coordinate system.  
- Stored in PostGIS for spatial queries.  

**Rule Engine**  
- Declarative rules persisted in DB.  
- In-memory evaluation for real-time detections.  
- Config changes published from Config Service to Analytics workers.  

**Heatmap**  
- Analytics periodically samples tracked positions (e.g., every 1s).  
- Data persisted as (`track_id`, `timestamp`, `x`, `y`, `zone_id`).  
- Aggregation into density maps is performed by the Heatmap Service in the Service Layer.  

---

### 2.3.4 Alarm Flow
1. Normalized detection arrives from `detections.normalized`.  
2. Geo-Mapper projects to site coordinates.  
3. Tracker updates object trajectory (`track_id`).  
4. Rule Engine evaluates zone/line/schedule.  
5. False-Alarm Filter validates persistence and plausibility.  
6. Alarm Builder attaches `frame_ref`, creates alarm, writes to Alarm Service.

---

### 2.3.5 Alarm Event Schema (example)

```json
{
  "alarm_id": "alarm-789",
  "track_id": "track-567",
  "site_id": "site-1",
  "zone_id": "zone-A",
  "object_type": "person",
  "first_seen": "2025-09-17T22:12:31Z",
  "position": {"x": 42.7, "y": 10.5},
  "evidence": ["s3://snapshots/site1/uuid-123.jpg"],
  "confidence": 0.86,
  "matched_rules": ["zone-entry", "schedule-active"]
}
```
---

### 2.3.6 KPIs & NFRs
- **False alarm rate** ≤ 10% (site-level metric).  
- **Detection latency** < 1s (p50/p95).  
- **Geo-accuracy** ≤ 3m (calibration-based).  

---

### 2.3.7 Testing & Validation
- Unit tests for geo-mapping and rule logic.  
- Synthetic replay harness for tracker + filter validation.  

---

## 2.4 Service Layer

### 2.4.1 Purpose
Provide backend business logic and APIs for operators and administrators. Responsibilities include:  
- Persist and manage alarms (lifecycle, evidence, reporting).  
- Orchestrate loudspeaker deterrence.  
- Store and distribute site/device/zones/schedules configuration.  
- Manage authentication, authorization, and auditing.  
- Provide heatmap and reporting data.  
- Support low-latency video verification via WebRTC signaling (media handled at Edge).  

---

### 2.4.2 Components

- **API Gateway (Node.js)**  
  - Expose REST endpoints for UI and external integrations.  
  - Authenticate JWT, enforce RBAC, apply throttling.  
  - Route requests to Alarm, Heatmap, Control, Config, and User services.  

- **Alarm Service (Go/Python)**  
  - Source of truth for alarm lifecycle (open → confirmed/dismissed → closed).  
  - Persists alarms with metadata from Analytics (`track_id`, `detection_ids`, `frame_refs`).  
  - Provides APIs for operators to confirm/dismiss alarms, add notes/tags, and close incidents.  
  - Pushes real-time updates to UI via WebSocket.  

- **Heatmap Service (Node.js/Python)**  
  - Consumes track data from Analytics Layer (not raw detections).  
  - Aggregates trajectories into spatio-temporal density maps.  
  - Provides tile-like endpoints for frontend visualization.  
  - Acts as the sole provider of heatmap queries; Analytics Layer only records raw track points.  

- **Control Service (Go)**  
  - Orchestrates loudspeaker playback.  
  - Selects the nearest speaker based on geo-coordinates from Analytics.  
  - Sends play/stop/test commands to Device Layer `/control` endpoint.  
  - Supports automatic deterrence message triggering on alarm creation.  

- **Auth/User Service (Node.js)**  
  - Issues JWTs, enforces RBAC (Admin / Operator / Viewer).  
  - Manages user accounts and role assignments.  
  - Session auto-expire ≤ 30 min.  
  - Audit logs for sensitive operations (alarm confirmation, config changes).  

- **Config Service**  
  - Stores zones, lines, schedules.  
  - Publishes change events via broker to Analytics (rule engine) and Collection.  
  - Provides APIs for operators to edit zones/lines/schedules via UI.  
  - Stores device registration info (camera/speaker ID, IP, model, position, heading, height) as received from Device Layer.  

- **WebRTC Signaling Service (Node.js/Go)**  
  - Handles SDP/ICE exchange for live video.  
  - Authenticated via JWT.  
  - Connects UI clients with the appropriate Edge WebRTC Gateway (media relay).  
  - Does not perform media transcoding; only manages signaling and session lifecycle.  
  - Sessions are ephemeral, not persisted.

  ### 2.4.3 Interfaces & APIs (examples)

**Alarms**
- `GET /api/v1/alarms` → list alarms with filters.  
- `POST /api/v1/alarms/{id}/confirm` → confirm alarm.  
- `POST /api/v1/alarms/{id}/dismiss` → dismiss alarm with reason.  
- `POST /api/v1/alarms/{id}/notes` → add note/tag.  

**Heatmap**
- `GET /api/v1/heatmap?site=site-1&from=...&to=...&zoom=...`  

**Control**
- `POST /api/v1/control/speaker/{id}/play` → play deterrence message.  

**Devices & Sites**
- `POST /api/v1/sites` → create site.  
- `POST /api/v1/sites/{id}/floorplan` → upload floor plan.  
- `POST /api/v1/devices` → register camera/speaker.  
- `GET /api/v1/devices` → list devices with health.  

**Config**
- `POST /api/v1/config/zones` → create/update zone.  
- `POST /api/v1/config/lines` → create/update virtual line.  
- `POST /api/v1/config/schedules` → update alarm schedules.  

**Users**
- `POST /api/v1/users` → create user.  
- `POST /api/v1/users/{id}/roles` → assign role.  

**WebRTC**
- `POST /webrtc/session` (SDP offer/answer)  
- `WS /webrtc/signal` (ICE exchange)  

---

### 2.4.4 Data Ownership & Transactions
- **Alarm Service**: sole authority for alarm lifecycle.  
- **Config Service**: sole authority for zones/lines/schedules.  
- **Heatmap Service**: sole authority for heatmap aggregation and queries. Consumes raw trajectory data from Analytics Layer; does not alter source detections.  
- **Control Service**: stateless orchestration, relies on Device Layer for execution.  
- **WebRTC sessions**: ephemeral, not persisted. Media relay is performed at Edge (Device Layer). Signaling and authentication are performed in the Service Layer.  

---

### 2.4.5 Scaling & Deployment Notes
- Start as a modular monolith (Node.js + Go + Python modules).  
- Sensitive data encrypted at rest (AES-256).  
- Audit logs stored in DB with immutable append-only policy.  
- JWT sessions auto-expire ≤ 30 min.  
- Evolve into microservices if scale demands.  
- Use Kubernetes HPA for Alarm Service and Control Service.  
- Stateful services (Postgres, MinIO) deployed as replicated clusters.  
- Audit logs for all role assignments and alarm closures.  

---

### 2.4.6 Failure Modes & Mitigation
- **API Gateway down** → load balancer + autoscaling.  
- **Alarm Service down** → alarms queued in broker, replay after recovery.  
- **Control Service failure** → no auto-trigger; notify operator.  
- **Config Service down** → Analytics uses last cached rules until recovery.  
- **Database write failure** → queue events in broker, retry with exponential backoff.  
- **WebRTC Signaling down** → UI cannot establish new sessions; operators fall back to snapshots. Existing media sessions at Edge Gateways continue until expiration.

---

## 2.5 Storage Layer

### 2.5.1 Purpose
Provide durable, compliant, and efficient storage for configuration, alarms, time-series metrics, and multimedia evidence (snapshots/clips).  
This layer is a shared infrastructure service: other layers use it, but it defines where data lives, how it is protected, and how it can be queried.  

---

### 2.5.2 Components & Responsibilities

- **PostgreSQL + PostGIS**  
  - Store site configs, zones, lines, devices, users.  
  - Support spatial queries for geo-mapping (e.g., `ST_Contains`, `ST_DWithin`).  
  - Serve as the authoritative source for configuration and alarm lifecycle data.  

- **Object Storage (S3 / MinIO)**  
  - Store snapshots and extracted clips.  
  - Enforce retention policies (e.g., auto-expire after N days).  
  - Provide signed URLs for secure evidence access.  

---

### 2.5.3 Data Retention & Compliance
- Per-tenant retention policies (configurable by admin).  
- **GDPR support:**  
  - Endpoints for data export (alarms, logs, snapshots).  
  - Endpoints for deletion of personal data (subject to lawful basis).  
- Encryption at rest (AES-256) for alarms, snapshots, logs.  

---

### 2.5.4 Backup & Recovery
- Regular backups for PostgreSQL (with WAL archiving).  
- Replication for S3/MinIO snapshots.  
- **RPO/RTO** aligned with system availability targets:  
  - 99% uptime  
  - ≤ 60s failover for services  

---

## 2.6 UI Layer (Frontend)

### 2.6.1 Purpose
Provide an operator dashboard for situational awareness and response:
- Map-based visualization of sites, zones, devices, and intruders.  
- Real-time alarm monitoring and operator actions.  
- Video verification via WebRTC popups.  
- Administrative configuration and user management.  

---

### 2.6.2 Tech & Structure
- **Stack:** Vue 3 + TypeScript + Canvas GL JS + WebSocket client + WebRTC player.  
- **Realtime:**  
  - WebSocket for alarms and device health.  
  - WebRTC for live video verification (on-demand).  
  - REST for config/history queries.  
- **Security:**  
  - Short-lived JWTs with httpOnly refresh cookie.  
  - RBAC-driven UI (Admin / Operator / Viewer).  

---

### 2.6.3 Main Modules
- **MapView:** Display zones, lines, cameras, intruder markers, heatmap overlay.  
- **AlarmPanel:** Show active alarms, confirm/dismiss with reason, add notes/tags.  
- **ConfigEditor:** Draw/edit zones and lines, manage schedules.  
- **DeviceAdmin:** Register devices, view health status.  
- **Reports:** Heatmap controls, CSV export, charts.  
- **UserMgmt:** Create accounts, assign roles.  
- **VideoPopup (WebRTC):** On alarm or map click, establish WebRTC session to stream live video from camera.  

---

### 2.6.4 UX Constraints
- Confirm/dismiss alarm ≤ 3 clicks.  
- WebRTC stream popup ≤ 3s after click.  
- Dismissal requires a false-alarm reason prompt.  

---

### 2.6.5 Interaction Model
- **Realtime events:**  
  - `alarm.created`, `alarm.updated`, `device.health` → via WebSocket.  

- **Video:**  
  - On-demand WebRTC session established via signaling server (part of backend).  
  - ICE/STUN/TURN servers ensure connectivity across NAT/firewalls.  
  - Snapshots always available as fallback evidence.  

- **Config & history:**  
  - CRUD via REST APIs (zones, lines, schedules, devices, users).  

---

## 3. Requirements Mapping

| Requirement Type   | Requirement (from SRS)                                                                 | Mapped Architecture Components                                                                 |
|--------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|
| **Functional**     | Create/edit site, upload floor plan, register cameras/speakers, configure zones/lines/schedules | Config Service, UI Layer (ConfigEditor, DeviceAdmin), PostgreSQL/PostGIS                       |
| **Functional**     | Track objects across multiple cameras and zones                                         | Analytics Layer (Tracker, Geo-Mapper, Rule Engine)                                             |
| **Functional**     | Evaluate zone crossings and detect intrusions in real time                             | Analytics Layer (Rule Engine, False-Alarm Filter)                                              |
| **Functional**     | Generate alarms with evidence (snapshots/clips)                                         | Analytics Layer (Alarm Builder), Alarm Service, Snapshot Service (S3/MinIO)                    |
| **Functional**     | Display intruder position and track live on map                                         | UI Layer (MapView), Analytics Layer (Tracker)                                                  |
| **Functional**     | Broadcast deterrence message via nearest speaker                                        | Control Service, Device Layer (Speaker Control)                                                |
| **Functional**     | Operator confirms/dismisses alarms, add notes/tags, close incidents                     | UI Layer (AlarmPanel), Alarm Service, Audit Logs                                               |
| **Functional**     | Operator views camera live video on map click                                           | UI Layer (VideoPopup), WebRTC Signaling Service, Device Layer (WebRTC Gateway)                 |
| **Functional**     | User management and role assignment                                                     | Auth/User Service, API Gateway (RBAC)                                                          |
| **Non-Functional** | Encrypt sensitive data at rest (AES-256)                                                | Storage Layer (Postgres, MinIO)                                                                |
| **Non-Functional** | GDPR: export/erase personal data, retention policies                                    | Storage Layer, Config Service, Auth/User Service                                               |
| **Non-Functional** | Idle sessions expire ≤30 min                                                            | Auth/User Service (JWT settings)                                                               |
| **Non-Functional** | System availability ≥99%, recovery ≤60s                                                 | Service failover logic                                                                          |
| **Non-Functional** | Support up to 30 concurrent users without degradation                                   | API Gateway, WebSocket handling, Service Layer autoscaling                                     |
| **Non-Functional** | False alarm rate ≤10%                                                                   | Analytics Layer (False-Alarm Filter, Rule Engine)                                              |
| **Non-Functional** | Confirm/dismiss alarms in ≤3 clicks                                                     | UI Layer (AlarmPanel UX)                                                                       |
| **Non-Functional** | Live video popup in ≤3s                                                                 | UI Layer (VideoPopup), WebRTC signaling                                                        |


---

## 4. Deployment Architecture

### 4.1 Topology
- **Edge nodes (per site or device cluster):**  
  Run Collector and Device Service close to cameras and speakers.  

- **Cloud region:**  
  Hosts API Gateway, Analytics, Alarm/Control/Heatmap services, database, and object storage.  

- **Frontend:**  
  Served as static assets from a cloud bucket or CDN.  

---

### 4.2 Deployment Approach

**MVP stage:**  
- Edge components deployed via Docker Compose.  
- Database and object storage run as single instances with regular backups.  
- Core services deployed as containers behind a load balancer.  

**Scale-out stage:**  
- Migrate to Kubernetes with StatefulSets for databases and HPA for stateless services.  
- Introduce CDN for global frontend delivery.  

---

### 4.3 CI/CD
- Automated build pipelines for frontend and backend.  
- Basic integration tests using synthetic detection replay.  
- Rolling updates for services.  

---

### 4.4 Monitoring & Operations
- Health checks for cameras, services, and database availability.  

---

## 5. Security, Compliance & Auditing

### 5.1 Authentication / Authorization
- JWT tokens with short expiry; refresh flow.  
- RBAC model: **admin**, **operator**, **viewer**.  
- Authorization enforced at API Gateway and Service Layer.  

### 5.2 Data Protection
- TLS for all external communication.  
- AES-256 encryption at rest (DB and object storage).  
- Audit logs for alarm confirmation/dismissal and config changes, stored append-only.  

### 5.3 GDPR & Data Subject Rights
- APIs:  
  - `POST /gdpr/export?subject={email}`  
  - `DELETE /gdpr/erase?subject={email}`  
- Start with a global retention policy (e.g., 30 days).  
- Soft-delete and JSON/CSV export.  

### 5.4 Penetration Testing & Hardening
- Web app security scans, dependency scanning, run-time scanning.  
- Regular audits and logging of suspicious activity.  

---

## 6. Observability, Metrics & Testing

### 6.1 Key Metrics to Collect
- **Latency:** detection → alarm (p50/p95), API response times.  
- **Availability:** uptime, per-service.  
- **Device health:** last seen, RTSP frame rate, metadata frequency.  

### 6.2 Tests
- Unit tests for rule engine and geo-mapping.  
- Integration tests: replay recorded camera metadata + frame snapshots to full pipeline.  

---

## 7. Technology Stack
- **Device:** Python (Axis SDK, RTSP)  
- **Server:** Node.js (API Gateway, Auth, Config), Python (Analytics, Heatmap), Go (Alarm, Control)  
- **Database:** PostgreSQL + PostGIS (configuration, spatial queries), MinIO or S3 (snapshots, evidence), SQLAlchemy ORM  
- **Frontend:** Vue + TypeScript, WebRTC player for live video verification  
- **Messaging:** MQTT (real-time events)  
- **Deployment:** Docker Compose  

---

## 8. Roadmap & Evolution Suggestions

**Phase 1 (MVP):**  
- Collector (ingest and normalize metadata)  
- Tracker (basic object tracking per camera, optional cross-camera correlation)  
- Rule Engine (zone/line/schedule filtering)  
- Alarm Service (lifecycle management, confirm/dismiss/close)  
- UI (map visualization + alarm panel)  
- Control Service (basic loudspeaker orchestration)  

**Phase 2:**  
- Heatmap Service (aggregate movement traces into density maps)  
- Reports (CSV export, charts, per-zone/per-time statistics)  
- Improved multi-camera tracking and false-alarm reduction  
- Enhanced Config Service (zones, lines, schedules, device registry)  

**Phase 3:**  
- LLM-based query interface for alarms/reports (natural language search)  
- Advanced ML models for detection and tracking  
- Evolution from modular monolith to microservices (Alarm, Heatmap, Auth, Config separated)  
- Multi-tenant hardening (per-tenant data isolation, retention policies, GDPR tooling)  

---

## 9. Appendix — Example Sequence: Alarm Creation (End-to-End)

1. The camera produces raw metadata (object type, bounding box, geo-coordinates).  
2. Device Layer forwards metadata to Collector via `/metadata`.  
3. Collector normalizes and publishes `detections.normalized`.  
4. Analytics consumes detections → Tracker assigns `track_id`, rules are evaluated.  
5. If a rule match passes filters, Alarm Builder creates an alarm event and `POST`s to Alarm Service (with snapshot/evidence refs).  
6. Alarm Service persists the alarm and pushes `alarm.created` to WebSocket topic.  
7. UI receives the event, highlights intruders on the map, shows a snapshot, and can open a live video popup if requested.  
8. If auto-deterrence is enabled, Alarm Service instructs Control Service to trigger the nearest speaker.  
9. Operator confirms or dismisses the alarm; Alarm Service updates state and writes audit log.  
